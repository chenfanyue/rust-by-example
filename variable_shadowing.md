在这段代码中，发生了一个名为**变量遮蔽（shadowing）**的概念，Rust 允许你使用同一个变量名重新声明一个变量。这段代码展示了这种行为，具体说明如下：

### 代码解析

```rust
fn main() {
    let a = 1;
    println!("{}", a); // 输出: 1

    let a = 2;
    println!("{}", a); // 输出: 2
}
```

1. **第一次声明 `a`**:
   ```rust
   let a = 1;
   ```
   - 这里声明了一个名为 `a` 的变量，并赋值为 `1`。
   - `println!("{}", a);` 打印这个变量的值，输出 `1`。

2. **第二次声明 `a`**:
   ```rust
   let a = 2;
   ```
   - 这里又声明了一个名为 `a` 的新变量。尽管变量名相同，但这是一个全新的变量，与之前的 `a` 是不同的。
   - Rust 允许这种行为，这被称为**变量遮蔽（shadowing）**。新的 `a` 会“遮蔽”之前的 `a`，从这一行之后，代码只会使用新的 `a`。
   - `println!("{}", a);` 打印新变量 `a` 的值，输出 `2`。

### 变量遮蔽的作用

- **变量遮蔽**允许你在同一作用域中重新声明变量，而不需要先手动释放或修改原变量。它避免了频繁使用不同的变量名（例如 `a1`, `a2`），使得代码更加简洁。
- 遮蔽时，新的变量会拥有与原变量不同的内存位置，旧变量在当前作用域内会被暂时“隐藏”。
- 这种机制不同于可变性。在这里，原始的 `a` 没有被修改或覆盖，而是创建了一个新的变量。

### 总结

在这段代码中，`a` 先被赋值为 `1`，之后被遮蔽，重新赋值为 `2`。由于是通过遮蔽实现的，Rust 并没有进行变量的修改，而是每次创建了一个新的 `a`，最终输出了两个不同的值：`1` 和 `2`。
