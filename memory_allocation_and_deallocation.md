我们可以将 "内存分配与释放" 作为所有权与内存管理部分的扩展，深入探讨以下几个方面：

### 3. 深入理解 Rust

#### 所有权与内存管理
##### 3.1 内存分配与释放

1. **栈与堆内存分配的基本概念**
   - 栈（Stack）：用于存储大小固定的、生命周期较短的局部变量。变量在作用域结束时自动释放，内存分配速度非常快。
   - 堆（Heap）：用于存储大小动态的、生命周期较长的数据结构，如 `Vec` 或 `Box`。堆内存需要显式分配和释放，开销较大。

2. **栈与堆的区别**
   - **分配速度**：栈的分配和释放速度非常快，因为它遵循后进先出（LIFO）的规则。堆内存分配较慢，需要通过操作系统管理内存。
   - **内存大小**：栈的大小在编译时确定，通常比较小。堆的内存大小可以动态调整，适合存储较大的数据。
   - **使用场景**：简单类型或生命周期短的数据放在栈中，而复杂类型或需要动态分配的内存放在堆中。

3. **Rust 中的内存分配**
   - Rust 通过 **所有权系统** 管理堆内存分配和释放。创建复杂对象（如 `Vec` 或 `Box`）时，内存从堆中分配，Rust 编译器确保这些对象的生命周期结束时，自动调用 `drop` 函数释放内存。
   - 栈上的数据在函数退出时自动清理，而堆上的内存需要通过所有权规则进行管理，避免手动释放内存的麻烦。

4. **智能指针和内存管理**
   - **Box<T>**: 将数据存储在堆中，同时遵守所有权规则。当 `Box<T>` 离开作用域时，其包含的数据会自动释放。
   - **Rc<T> 和 Arc<T>**: 引用计数类型，允许多个所有者共享堆分配的数据。计数为零时，数据自动释放。
   - **RefCell<T> 和 Mutex<T>**: 提供内部可变性和线程安全的可变引用，允许在编译时检查不到的场景下执行借用检查。

5. **内存释放**
   - Rust 的内存管理系统基于 RAII（Resource Acquisition Is Initialization）原则。在所有权转移或作用域结束时，Rust 自动调用析构函数，释放相应的堆内存。
   - 如果使用 `Box`、`Vec` 等堆分配类型，当它们的所有者作用域结束时，Rust 会递归地释放其持有的堆内存。

通过这些内容的深入学习，能够帮助理解 Rust 如何通过所有权系统和 RAII 来保证内存的高效管理和安全释放。