函数签名中已经通过 mut self 隐式地要求 Self 是 Sized，因为只有 Sized 类型才能通过值传递
请详细解读这句话
这句话的意思是，当你在函数签名中使用 `mut self` 时，它实际上已经隐含了一个重要约束：类型 `Self` 必须是 **`Sized`** 的。也就是说，`Self` 的大小在编译时必须是已知的。

### 解读分步详解

1. **`Sized` 的概念**：
   在 Rust 中，类型可以分为两类：**有固定大小**（`Sized`）的类型和**无固定大小**（`?Sized`）的类型。大多数类型，比如 `i32`、`Vec<T>`、`String`，它们的大小在编译时是已知的，因此它们都是 `Sized` 类型。而一些动态类型，比如切片 `[T]`、`dyn Trait`，它们的大小在编译时是未知的，因此属于 `?Sized` 类型。

   `Sized` 类型有一个明确的大小，这使得它们可以通过值（即按位）传递。`?Sized` 类型没有固定大小，不能通过值传递，只能通过引用传递。

2. **`self` 参数的传递方式**：
   在函数签名中，`self` 参数可以有多种传递方式：
   
   - `self`：表示函数接收当前实例的所有权，这会通过值传递实例。
   - `&self`：表示函数通过不可变引用借用当前实例。
   - `&mut self`：表示函数通过可变引用借用当前实例。
   - `mut self`：表示函数通过值传递实例，并且允许对实例进行修改。

   其中，`self` 和 `mut self` 都是通过值传递实例的意思。对于通过值传递来说，编译器必须知道这个类型的大小，以便在栈上分配空间和处理内存布局。因此，`self` 和 `mut self` 的参数类型隐式要求 `Self` 类型必须是 `Sized`，即在编译时具有已知大小。

3. **`Sized` 约束的隐含性**：
   当你在函数签名中使用 `self` 或 `mut self`，实际上已经告诉编译器该类型是 `Sized`，因为只有 `Sized` 类型才能通过值传递。如果 `Self` 类型是 `?Sized`（如动态大小类型），则无法通过值传递，只能通过引用传递。

   例如，以下函数签名隐式要求 `Self` 类型是 `Sized`，因为它通过值传递：
   ```rust
   fn consume(self);
   ```

   而以下签名则允许 `Self` 是 `?Sized`，因为它通过引用传递：
   ```rust
   fn borrow(&self);
   fn borrow_mut(&mut self);
   ```

4. **`Sized` 约束的冗余性**：
   如果在函数签名中已经使用了 `self` 或 `mut self`，那么对 `Self` 类型的 `Sized` 约束是隐式的，不需要显式地在 `where` 子句中再声明 `Self: Sized`。因为这已经由 `self` 或 `mut self` 的传递方式自动保证了。

   例如，下面的代码显式地添加了 `Self: Sized` 约束，但实际上这是多余的，因为 `mut self` 已经隐式要求 `Self` 是 `Sized`：
   ```rust
   fn collect(mut self) -> Vec<Self::Item>
   where
       Self: Sized,
   {
       // 函数体
   }
   ```

   你可以直接简化为：
   ```rust
   fn collect(mut self) -> Vec<Self::Item> {
       // 函数体
   }
   ```

### 总结

- 当你在函数签名中使用 `mut self` 或 `self` 传递实例时，Rust 编译器隐式地要求 `Self` 类型是 `Sized`，即在编译时具有已知大小，因为通过值传递需要知道大小来进行内存分配。
- 因此，`Self: Sized` 是一个隐含的约束，不需要显式地再写出来。这就是为什么说 "只有 `Sized` 类型才能通过值传递"。

