### 1.2 所有权转移 (Move)

#### 1.2.1 解释什么是所有权转移

所有权转移（Move）是 Rust 中一个重要的概念，用于描述当一个值的所有权从一个变量转移到另一个变量时发生的情况。具体来说，所有权转移的机制遵循以下原则：

- **唯一性**: 在 Rust 中，每一个值都有且只有一个所有者。当所有权从一个变量转移到另一个变量时，原有的所有者失去了对该值的控制权，新变量成为该值的唯一所有者。

- **不可复制性**: 默认情况下，非基本类型的数据（如 `String`、`Vec`）在所有权转移时不会进行深拷贝，而是直接将所有权转移给新的变量。这样做可以避免不必要的内存开销，提高性能。

- **原变量无效化**: 一旦所有权被转移，原有的变量将不再有效，任何对原变量的操作都会导致编译错误。这种机制有效地避免了数据竞争和内存错误。

#### 1.2.2 何时会发生所有权转移

所有权转移主要发生在以下几种情况下：

1. **变量赋值**: 当一个值赋给另一个变量时，所有权转移发生，原变量不再拥有该值的所有权。

   - 示例: `let s2 = s1;` 这行代码将 `s1` 的所有权转移给了 `s2`。

2. **函数传参**: 当一个变量作为参数传递给函数时，所有权转移发生，函数获得该值的所有权，而调用者失去了对该值的控制。

   - 示例: `takes_ownership(s1);` 调用这个函数时，`s1` 的所有权被转移到 `takes_ownership` 函数内，函数执行结束后，`s1` 将不再有效。

3. **返回值**: 当函数返回一个值时，所有权也会发生转移。调用者将获得该值的所有权，而函数内的临时变量将不再拥有该值。

   - 示例: `let s2 = gives_ownership();` 这个函数返回的值的所有权被转移给了 `s2`。

通过这些规则，Rust 确保了内存的安全管理，避免了常见的内存错误。

#### 1.2.3 示例代码

以下是一些示例代码，展示了所有权转移在变量赋值和函数传参时的工作方式。

##### 1.2.3.1 变量赋值时的所有权转移

```rust
fn main() {
    let s1 = String::from("hello"); // s1 拥有 "hello" 字符串的所有权
    let s2 = s1; // 所有权转移：s2 现在拥有 "hello" 的所有权，s1 无效

    // println!("{}", s1); // 错误：s1 已失效，不能再使用
    println!("{}", s2); // 输出 "hello"
} // 当 s2 超出作用域，"hello" 字符串的内存被释放
```

在这个例子中，`s1` 拥有 `"hello"` 字符串的所有权。当我们将 `s1` 赋值给 `s2` 时，`s1` 的所有权被转移给了 `s2`。因此，`s1` 变得无效，无法再使用。`s2` 超出作用域后，字符串 `"hello"` 的内存将被释放。

##### 1.2.3.2 函数传参时的所有权转移

```rust
fn main() {
    let s1 = String::from("hello"); // s1 拥有 "hello" 字符串的所有权

    takes_ownership(s1); // s1 的所有权被转移给函数 takes_ownership

    // println!("{}", s1); // 错误：s1 已失效，不能再使用
}

fn takes_ownership(some_string: String) { // some_string 获取所有权
    println!("{}", some_string); // 输出 "hello"
} // 当 some_string 超出作用域，"hello" 字符串的内存被释放
```

在这个示例中，`takes_ownership` 函数获取了传递给它的 `String` 类型变量 `s1` 的所有权。`s1` 被传递后，原变量 `s1` 就失去了所有权，并且在 `main` 函数中不能再使用。函数 `takes_ownership` 中的 `some_string` 在函数结束后被释放。

##### 1.2.3.3 函数返回值时的所有权转移

```rust
fn main() {
    let s1 = gives_ownership(); // gives_ownership 返回值的所有权被转移给 s1

    let s2 = String::from("hello"); // s2 拥有 "hello" 字符串的所有权

    let s3 = takes_and_gives_back(s2); // s2 的所有权被转移给函数并返回，s3 获得所有权

    println!("{}", s1); // 输出 "hello"
    // println!("{}", s2); // 错误：s2 已失效，不能再使用
    println!("{}", s3); // 输出 "hello"
}

fn gives_ownership() -> String {
    let some_string = String::from("hello"); // some_string 获取所有权

    some_string // 返回 some_string 的所有权
}

fn takes_and_gives_back(a_string: String) -> String {
    a_string // 返回传入的字符串的所有权
}
```

在这个例子中，函数 `gives_ownership` 返回了一个字符串的所有权，并将其赋值给 `s1`。函数 `takes_and_gives_back` 接受一个字符串作为参数，将其所有权转移到函数内部，再返回该字符串并将其所有权赋值给 `s3`。`s2` 的所有权已经被转移，因此不能再使用。

这些示例展示了所有权转移在变量赋值、函数传参和返回值时的表现。理解这些概念有助于掌握 Rust 的内存管理和资源管理机制。