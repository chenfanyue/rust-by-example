在 `let x: i32 = 1; let ptr_const: *const i32 = &x;` 这段代码中，实际上发生了 **自动类型转换**，从引用类型 `&i32` 转换为裸指针类型 `*const i32`。这是因为 Rust 允许从引用（`&T` 或 `&mut T`）自动转换为相应的裸指针类型（`*const T` 或 `*mut T`）：

- `&T` 可以自动转换为 `*const T`。
- `&mut T` 可以自动转换为 `*mut T`。

### 为什么能自动转换？

- `&T` 是一个 **不可变引用**，它指向一个内存地址，受借用检查器的管理。
- `*const T` 是一个 **不可变裸指针**，也指向同样的内存地址，但它不受借用检查器的约束。

虽然这两者在内存中都表示为一个指向同一块内存的指针，但它们的行为不同：
- **引用（`&T`）**：受到 Rust 的借用检查机制的保护，保证数据在多个引用间的安全性。
- **裸指针（`*const T`）**：没有任何安全保障，必须在 `unsafe` 块中使用。

### 自动类型转换的过程

当你写 `let ptr_const: *const i32 = &x;` 时，编译器会隐式地将 `&i32` 类型的引用转换为 `*const i32` 类型的裸指针。这种转换是非常安全的，因为裸指针和引用在底层都指向同一块内存区域，只是处理方式不同。

#### 示例：
```rust
fn main() {
    let x: i32 = 1;
    let ptr_const: *const i32 = &x;  // 自动类型转换发生了
    println!("Address of x: {:?}", ptr_const);
}
```

在这里，`&x` 是一个 `&i32` 类型的引用，编译器自动将它转换为 `*const i32`，从而赋值给 `ptr_const`。

### 需要注意的几点：
1. **自动转换是单向的**：`&T` 可以自动转换为 `*const T`，但裸指针 `*const T` 无法自动转换回引用 `&T`，你需要手动在 `unsafe` 块中进行转换。
   
   ```rust
   let ref_x: &i32 = unsafe { &*ptr_const }; // 从 *const i32 转换为 &i32
   ```

2. **自动转换不影响指针的可变性**：当你将 `&T` 转换为 `*const T` 时，转换后的裸指针依然是不可变的，你不能通过这个指针修改数据。

3. **安全性**：尽管自动转换发生了，`*const T` 并不享有引用的安全性保障，所以你必须小心操作这些裸指针，尤其是在 `unsafe` 块中。

### 总结：
- `let ptr_const: *const i32 = &x;` 之所以可以这样写，是因为 Rust 允许从引用（`&i32`）自动转换为相应的裸指针（`*const i32`）。
- 这种转换是自动完成的，是因为引用和裸指针在底层都表示为指针，但引用有借用规则的保护，而裸指针没有。